#region Usings

using System;
using System.Collections.Generic;
using System.Threading.Tasks;

#endregion

namespace RabbitLink.Topology
{
    /// <summary>
    /// Topology configurator
    /// </summary>
    public interface ILinkTopologyConfig
    {
        /// <summary>
        /// Declare new exchange or return already existent if all settings match
        /// </summary>
        /// <param name="name">name of exchange</param>
        /// <param name="type">type of exchange</param>
        /// <param name="durable">is exchage durable</param>
        /// <param name="autoDelete">exchange must be deleted after all queues disconnect</param>
        /// <param name="alternateExchange">alternative exchange for messages which cannot be routed by this exchage</param>
        /// <param name="delayed">is exchange can handler delayed messages (need plugin in RabbitMQ)</param>
        Task<ILinkExchage> ExchangeDeclare(
            string name,
            LinkExchangeType type,
            bool durable = true,
            bool autoDelete = false,
            string alternateExchange = null,
            bool delayed = false
            );

        /// <summary>
        /// Returns already declared exchage by name
        /// </summary>
        /// <param name="name">name of exchange</param>
        Task<ILinkExchage> ExchangeDeclarePassive(string name);
        
        /// <summary>
        /// Returns default RabbitMQ exchange
        /// </summary>
        Task<ILinkExchage> ExchangeDeclareDefault();
        
        /// <summary>
        /// Deletes exchange
        /// </summary>
        /// <param name="exchange">exchange for delete</param>
        /// <param name="ifUnused">delete only if exchange is unused</param>
        /// <returns></returns>
        Task ExchangeDelete(ILinkExchage exchange, bool ifUnused = false);

        /// <summary>
        /// Declare exclusite queue with name generated by server
        /// </summary>
        Task<ILinkQueue> QueueDeclareExclusiveByServer();

        /// <summary>
        /// Declare exclusive queue with name generated by library
        /// </summary>
        /// <param name="autoDelete">is queue must be delete when all consumers are gone</param>
        /// <param name="messageTtl">ttl for messages</param>
        /// <param name="expires">timeout to delete queue when all consumer are gone</param>
        /// <param name="maxPriority">maximum priority of message</param>
        /// <param name="maxLength">maximum length of queue</param>
        /// <param name="maxLengthBytes">maximum length of queue in bytes</param>
        /// <param name="deadLetterExchange">exhange where message will be passed when NACKed by consumer</param>
        /// <param name="deadLetterRoutingKey">routing key for message when NACKed by consumer and routed to dead letter exchange</param>
        Task<ILinkQueue> QueueDeclareExclusive(
            bool autoDelete = true,
            TimeSpan? messageTtl = null,
            TimeSpan? expires = null,
            byte? maxPriority = null,
            int? maxLength = null,
            int? maxLengthBytes = null,
            string deadLetterExchange = null,
            string deadLetterRoutingKey = null
            );

        /// <summary>
        /// Declare exclusive queue with name generated by library with prefix specified by caller
        /// </summary>
        /// <param name="prefix">name prefix</param>
        /// <param name="autoDelete">is queue must be delete when all consumers are gone</param>
        /// <param name="messageTtl">ttl for messages</param>
        /// <param name="expires">timeout to delete queue when all consumer are gone</param>
        /// <param name="maxPriority">maximum priority of message</param>
        /// <param name="maxLength">maximum length of queue</param>
        /// <param name="maxLengthBytes">maximum length of queue in bytes</param>
        /// <param name="deadLetterExchange">exhange where message will be passed when NACKed by consumer</param>
        /// <param name="deadLetterRoutingKey">routing key for message when NACKed by consumer and routed to dead letter exchange</param>
        Task<ILinkQueue> QueueDeclareExclusive(
            string prefix,
            bool autoDelete = true,
            TimeSpan? messageTtl = null,
            TimeSpan? expires = null,
            byte? maxPriority = null,
            int? maxLength = null,
            int? maxLengthBytes = null,
            string deadLetterExchange = null,
            string deadLetterRoutingKey = null
            );

        /// <summary>
        /// Returns already declared queue by name
        /// </summary>
        Task<ILinkQueue> QueueDeclarePassive(string name);

        
        /// <summary>
        /// Declare new queue or return already existent if all settings match
        /// </summary>
        /// <param name="name">name of queue</param>
        /// <param name="durable">is queue durable</param>
        /// <param name="exclusive">is queue exclusive (may be used by only one consumer)</param>
        /// <param name="autoDelete">is queue must be delete when all consumers are gone</param>
        /// <param name="messageTtl">ttl for messages</param>
        /// <param name="expires">timeout to delete queue when all consumer are gone</param>
        /// <param name="maxPriority">maximum priority of message</param>
        /// <param name="maxLength">maximum length of queue</param>
        /// <param name="maxLengthBytes">maximum length of queue in bytes</param>
        /// <param name="deadLetterExchange">exhange where message will be passed when NACKed by consumer</param>
        /// <param name="deadLetterRoutingKey">routing key for message when NACKed by consumer and routed to dead letter exchange</param>
        Task<ILinkQueue> QueueDeclare(
            string name,
            bool durable = true,
            bool exclusive = false,
            bool autoDelete = false,
            TimeSpan? messageTtl = null,
            TimeSpan? expires = null,
            byte? maxPriority = null,
            int? maxLength = null,
            int? maxLengthBytes = null,
            string deadLetterExchange = null,
            string deadLetterRoutingKey = null
            );

        /// <summary>
        /// Deletes queue
        /// </summary>
        /// <param name="queue">queue for delete</param>
        /// <param name="ifUnused">delete queue only if it have no consumers</param>
        /// <param name="ifEmpty">delete queue inly if no messages in it</param>
        /// <returns></returns>
        Task QueueDelete(ILinkQueue queue, bool ifUnused = false, bool ifEmpty = false);
        
        /// <summary>
        /// Purge queue (remove all messages)
        /// </summary>
        /// <param name="queue">queue for purge</param>
        Task QueuePurge(ILinkQueue queue);

        /// <summary>
        /// Binds one exchange to another
        /// </summary>
        /// <param name="destination">destination exchange (consumer)</param>
        /// <param name="source">source exchange (producer)</param>
        /// <param name="routingKey">routing key</param>
        /// <param name="arguments">additional arguments</param>
        /// <returns></returns>
        Task Bind(ILinkExchage destination, ILinkExchage source, string routingKey = null,
            IDictionary<string, object> arguments = null);

        /// <summary>
        /// Binds queue to exchange
        /// </summary>
        /// <param name="queue">queue (consumer)</param>
        /// <param name="exchange">exchange (producer)</param>
        /// <param name="routingKey">routing key</param>
        /// <param name="arguments">additional arguments</param>
        /// <returns></returns>
        Task Bind(ILinkQueue queue, ILinkExchage exchange, string routingKey = null,
            IDictionary<string, object> arguments = null);
    }
}